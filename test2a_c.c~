
#include <stdio.h>

/*This is the rewriting of Rocco's matlab code to C*/
#define xnum 101
#define ynum 51


float Max (float a[ynum][xnum])
{
    float maxinum=a[0][0];
    int m,n;
    for(m=0;m<ynum;m++)
        for(n=0;n<xnum;n++)
    {
        if(a[m][n]>maxinum)
        {
            maxinum=a[m][n];
        }
    }
    return maxinum;
}

float Max1 (float a, float b)
{
    if(a>b)
         return a;
    else
         return b;
}

float Min (float a[ynum][xnum])
{
    float minimum=a[0][0];
    int m,n;
    for(m=0;m<ynum;m++)
        for(n=0;n<xnum;n++)
    {
        if(a[m][n]<minimum)
        {
            minimum=a[m][n];
        }
    }
    return minimum;
}

float Min1 (float a, float b)
{
    if(a<b)
         return a;
    else
         return b;
}

/*
solver(float *a)
{
    *(a+3*xnum+3)=7; // solver(&Kx[0][0]),then Kx[3][3] will be assigned 7
}
*/

void solver(float dx_, float dy_, double dt_, float *h0_, float *h1_,
            float *Kx_, float *Ky_, float *Ss_, float *Q_, float v0_)
{
    int i,j,r;
    float ka,kb,kc,kd,vxa,vxb,vyc,vyd,kappa_1;

    // internal values following pages 139-140 in Gerya's book
    for(i=1;i<ynum-1;i++)
    {
        for(j=1;j<xnum-1;j++)
        {
            r=i*xnum;
            ka=(*(Kx_+r+j-1)+*(Kx_+r+j))/2;
            kb=(*(Kx_+r+j+1)+*(Kx_+r+j))/2;
            kc=(*(Kx_+r-xnum+j)+*(Kx_+r+j))/2;
            kd=(*(Kx_+r+xnum+j)+*(Kx_+r+j))/2;
            vxa=-ka*(*(h0_+r+j)-*(h0_+r+j-1))/dx_;
            vxb=-kb*(*(h0_+r+j+1)-*(h0_+r+j))/dx_;
            vyc=-kc*(*(h0_+r+j)-*(h0_+r-xnum+j))/dy_;
            vyd=-kd*(*(h0_+r+xnum+j)-*(h0_+r+j))/dy_;
            kappa_1=dt_/(*Ss_+r+j);
            *(h1_+r+j)=*(h0_+r+j)+*(Q_+r+j)/(*(Ss_+r+j))-
                        kappa_1*((vxb-vxa)/dx_+(vyd-vyc)/dy_);
        }
    }
    printf("\n%f\n",*(Kx_+3*xnum+3));

    //fix surface hydraulic values to 0
    for (j=0;j<xnum;j++)
        *(h1_+j)=0;


    //left side boundary condition: on flow


}

void main()
{
    //Model size
    long int xsize=5e4;
    long int ysize=5e3;

    //Numbers of nodes
    //int xnum=101;
    //int ynum=51;

    //Number of time steps
    long int maxtnum=1e4;

    //Initial hydraulic uniform head value
    float H0=0;
    float h0[ynum][xnum];
    float h1[ynum][xnum];

    //background permeability for x and y direction.
    float kxbg=1;
    float kybg=1.5;

    //Source at the bottom
    int Ls=3500;
    int xlS=0.5*xsize-0.5*Ls;
    int xrS=0.5*xsize+0.5*Ls;
    float v0=100/Ls;

    //high K blocks
    int nb=0; //number of blocks, no blocks first

    float dx=xsize/(xnum-1);
    float dy=ysize/(ynum-1);

    //Specific storage uniform......
    float ss=1;
    float Ss[ynum][xnum];
    float Kx[ynum][xnum];
    float Ky[ynum][xnum];
    float Q[ynum][xnum];
    int i,j;
    for (i=0;i<ynum;i++)
    {
        for(j=0;j<xnum;j++)
        {
            Ss[i][j]=ss;
            Kx[i][j]=kxbg;
            Ky[i][j]=kybg;
            Q[i][j]=0;
        }
    }

    //diffusivity for computing time step
    float kappax=Max(Kx)/Min(Ss);
    float kappay=Max(Ky)/Min(Ss);
    float kappa=Max1(kappax,kappay);

    //time step limit, [book]introduction to numerical geodynamic modelling p134, equation (10.4)
    double dtexp=100*100.0/(3*1.5);
    //time step
    double dt=1.0*dtexp;

    int time=0;
    int it;


    Kx[3][3]=8;
    solver(dx,dy,dt,&h0[0][0],&h1[0][0],&Kx[0][0],&Ky[0][0],&Ss[0][0],&Q[0][0],v0);

    /*for(it=0;it<=maxtnum;it++)
    {
        solver(dx,dy,dt,h0,h1,Kx,Ky,Ss,Q,V0);
        //flow();

    }*/

    //plot the results in matlab

    printf("%f,%f,%f,%f,%d\n",dx,dy,Kx[3][3],kappa,i);


}
